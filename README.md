# Database Course Demonstration (PostgreSQL)

This demonstration package covers SQL fundamentals, advanced query patterns, ORM usage (good and bad), and performance optimization using PostgreSQL.

## Files

| File | Description |
|------|-------------|
| `database_demo.sql` | SQL schema, data, and progressive query examples |
| `orm_demo.py` | Python SQLAlchemy ORM demonstration |
| `README.md` | This file |

## Prerequisites

### PostgreSQL Installation

**macOS (Homebrew):**
```bash
brew install postgresql@15
brew services start postgresql@15
```

**Ubuntu/Debian:**
```bash
sudo apt update
sudo apt install postgresql postgresql-contrib
sudo systemctl start postgresql
```

**Windows:**
Download from https://www.postgresql.org/download/windows/

**Add PostgreSQL to PATH**
```bash
echo 'export PATH="/opt/homebrew/opt/postgresql@15/bin:$PATH"' >> ~/.zshrc
```
or equivalent.

### Python Dependencies

```bash
pip install sqlalchemy psycopg2-binary
```

## Running the SQL Demonstration

### Setup

```bash
# Create the database
createdb demo_db

# Run the SQL file
psql demo_db < database_demo.sql

# Or run interactively
psql demo_db
\i database_demo.sql
```

### Interactive Exploration

```bash
psql demo_db

# Useful psql commands:
\dt                     # List all tables
\d products             # Describe a table
\di                     # List all indexes
\x                      # Toggle expanded display
\timing                 # Toggle query timing
```

## Running the Python ORM Demonstration

### Quick Start

```bash
# Create database (if not already created)
createdb demo_db

# Run the demo
python orm_demo.py
```

### Custom Database Connection

```bash
# Using environment variable
DATABASE_URL=postgresql://user:password@localhost:5432/demo_db python orm_demo.py
```

To see all SQL queries generated by the ORM, ensure `SHOW_SQL = True` at the top of the file (enabled by default).

## What's Covered

### SQL Topics (`database_demo.sql`)

1. **Schema Design** (Part 1)
   - 5 normalized tables with proper relationships
   - Foreign keys and constraints
   - Self-referential relationships (categories)
   - PostgreSQL `SERIAL` for auto-increment

2. **Simple Queries** (Part 3)
   - SELECT with specific columns
   - WHERE clause filtering
   - ORDER BY and LIMIT/OFFSET
   - NULL handling with COALESCE
   - String operations with LIKE and ILIKE (case-insensitive)

3. **JOIN Types** (Part 4)
   - INNER JOIN - matching rows only
   - LEFT JOIN - all from left table
   - RIGHT JOIN - all from right table
   - FULL OUTER JOIN - all from both tables (native PostgreSQL support)
   - Self JOIN - table joined to itself
   - Multiple JOINs across tables

4. **Aggregations** (Part 5)
   - COUNT, SUM, AVG, MIN, MAX
   - GROUP BY with NULLS LAST
   - HAVING clause
   - Complex aggregations with JOINs

5. **Efficient vs Inefficient Queries** (Part 6)
   - Index creation and usage
   - Function on indexed columns (bad)
   - OR vs UNION
   - SELECT * problems
   - EXISTS vs IN subqueries
   - Correlated subqueries (N+1 problem in SQL)
   - LIKE with leading wildcard
   - Unnecessary DISTINCT
   - Premature sorting

6. **Query Planner** (Part 7)
   - EXPLAIN usage
   - EXPLAIN ANALYZE for actual timing
   - EXPLAIN (ANALYZE, BUFFERS) for cache analysis
   - Understanding Seq Scan vs Index Scan
   - Comparing query alternatives

7. **Advanced Topics** (Part 8)
   - Common Table Expressions (WITH)
   - Window functions (RANK, ROW_NUMBER, LAG, LEAD)
   - CASE expressions
   - PostgreSQL-specific: FILTER clause, RETURNING, ARRAY_AGG, STRING_AGG

### ORM Topics (`orm_demo.py`)

1. **Model Definitions**
   - SQLAlchemy declarative models
   - Relationships (one-to-many, many-to-many)
   - Constraints and defaults

2. **Good Patterns**
   - Filtered queries
   - Eager loading (joinedload, selectinload)
   - Aggregations in ORM
   - Column selection
   - EXISTS subqueries
   - Bulk operations

3. **Bad Patterns** (with detailed explanations)
   - N+1 query problem
   - Loading unnecessary data
   - Queries inside loops
   - Python filtering instead of SQL
   - Lazy loading during serialization
   - Improper transaction handling
   - Long-lived sessions
   - Raw SQL injection risks

4. **Performance Tips Summary**
   - 10 key practices for ORM performance

## Query Planner Quick Reference

### Basic EXPLAIN

```sql
-- Shows the query plan (does not execute)
EXPLAIN
SELECT * FROM products WHERE manufacturer_id = 1;
```

### EXPLAIN ANALYZE

```sql
-- Actually executes the query and shows real timing
EXPLAIN ANALYZE
SELECT * FROM products WHERE manufacturer_id = 1;
```

### EXPLAIN with BUFFERS

```sql
-- Shows buffer/cache usage
EXPLAIN (ANALYZE, BUFFERS)
SELECT * FROM products WHERE manufacturer_id = 1;
```

### EXPLAIN Output Formats

```sql
-- JSON format (useful for programmatic analysis)
EXPLAIN (ANALYZE, BUFFERS, FORMAT JSON)
SELECT * FROM products WHERE manufacturer_id = 1;

-- Other formats: TEXT (default), YAML, XML
```

### Key Things to Look For

| Plan Node | Meaning | Performance |
|-----------|---------|-------------|
| Seq Scan | Sequential scan (reads all rows) | Often slow on large tables |
| Index Scan | Uses index to find rows | Usually good |
| Index Only Scan | All data from index | Best! |
| Bitmap Heap Scan | Bitmap from index, then fetch | Good for ranges |
| Nested Loop | For each outer row, scan inner | Good with index |
| Hash Join | Build hash table, probe | Good for large tables |
| Merge Join | Merge sorted inputs | Good when sorted |

## Key Concepts for Students

### JOIN Types Visual

```
Table A         Table B
+---+          +---+
| 1 |          | 1 |
| 2 |          | 2 |
| 3 |          | 4 |
+---+          +---+

INNER JOIN:     Returns 1, 2       (matching only)
LEFT JOIN:      Returns 1, 2, 3    (all A + matching B)
RIGHT JOIN:     Returns 1, 2, 4    (all B + matching A)
FULL OUTER:     Returns 1, 2, 3, 4 (all from both)
```

### N+1 Problem Illustration

```
BAD (N+1 queries):
Query 1: SELECT * FROM orders                    -- 1 query
Query 2: SELECT * FROM products WHERE id = 1    -- +
Query 3: SELECT * FROM products WHERE id = 2    -- +
Query 4: SELECT * FROM products WHERE id = 3    -- + N queries
...                                              -- = N+1 total

GOOD (2 queries):
Query 1: SELECT * FROM orders                    -- 1 query
Query 2: SELECT * FROM products WHERE id IN (1,2,3...)  -- 1 query
                                                 -- = 2 total
```

### When to Use Each ORM Loading Strategy

| Strategy | Use Case | Queries |
|----------|----------|---------|
| `joinedload()` | Many-to-one (product→manufacturer) | 1 (with JOIN) |
| `selectinload()` | One-to-many (order→items) | 2 (SELECT + IN) |
| `subqueryload()` | One-to-many with complex filters | 2 (SELECT + subquery) |
| `lazyload()` | Rarely accessed relationships | N+1 (avoid in loops!) |

### PostgreSQL-Specific Features Demonstrated

- `SERIAL` / `BIGSERIAL` for auto-increment
- `ILIKE` for case-insensitive pattern matching
- Native `FULL OUTER JOIN` support
- `NULLS FIRST` / `NULLS LAST` in ORDER BY
- `FILTER` clause for conditional aggregation
- `RETURNING` clause for INSERT/UPDATE/DELETE
- `ARRAY_AGG` and `STRING_AGG` for array/string aggregation
- `EXTRACT()` for date/time parts
- Rich `EXPLAIN ANALYZE` output with timing and buffers

## Troubleshooting

### Connection Refused
```bash
# Check if PostgreSQL is running
pg_isready

# Start PostgreSQL (macOS)
brew services start postgresql@15

# Start PostgreSQL (Linux)
sudo systemctl start postgresql
```

### Permission Denied
```bash
# Create a role matching your username
sudo -u postgres createuser --superuser $USER
```

### Database Does Not Exist
```bash
createdb demo_db
```

## License

Educational use permitted.
